/* 类型转换 */


/*---------------------------------- 例子------------------------------ */
/* 当一个运算符的几个操作数类型不同时，就需要通过一些规则把它们转换为某种共同的类型，一般来说，自动转换实质把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换*/
/*
   由于char类型就是较小的整形，因此在算术表达式中可以自由使用char类型变量，如下面的函数atoi，它将一串数字转换为响应的数值：
*/
/* atoi: convert s to integer */

int atoi(char s[])
{
	int i, n;
	n = 0;
	for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)
	{
		n = 10 * n + (s[i] - '0');
	}
	return n;
}

/* 函数lower是将char类型转换为int类型的另外一个例子，它将ASCII字符集中的字符映射到对应的小写字母，如果待转换的字符不是大写字母,lower函数将返回字符本身*/
/* lower: convert c to lower case ; ASCII only */

int lower(int c)
{
	if (c >= 'A' && c <= 'z')
	{
		return c + 'a' - 'A';
	}
	else
	{
		return c;
	}
}
/* 上面的函数是为ASCII字符集设计的*/

/* 
   （1）将字符类型转换为整形时，需要注意：C语言没有指定char类型的变量是无符号变量（signed）还是带符号变量（unsigned）
   （2）当把一个char类型的值转换为int类型的值时，对不同的机器，其结果也不同。在某些机器中，如果char 类型值的最左侧为1，则转换为负整数，而在另外一些机器中，把char类型之转换为int类型时，在char 类型值的左侧添加0
   （3）C语言中保证机器的标准打印字符不会是负值，但是，存储在字符变量中的位模式在某些机器中可能是负值，而在另外一些机器中可能为正值，所以为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好指定signed或者unsigned限定符
*/

/* 
   C语言中，很多情况下会惊醒隐式的算术类型转换，一般来说，如果二元运算符的两个操作数据有不同的类型，那么在进行运算之前先要把“较低”的类型提升为“较高”的类型，运算的结果为较高的类型
   （1）如果其中一个操作数的类型为long double，则将另一个操作数转换为long double类型
   （2）如果其中一个操作数的类型为double，则将另一个操作数转换为double类型
   （3）如果其中一个操作数的类型为float，则将另一个操作数转换为float类型
   （4）将char与short类型的操作数转换为int类型
   （5）如果其中一个操作数的类型为long，则将另一个操作数页转换为long类型
   （6）当表达式中含有unsigned类型的操作数时，转换规则要复杂一些，原因在于带符号值与无符号值之间的比较运算是与机器相关的，应为它们取决于机器中不同整数类型的大小
   （7）赋值时也是要进行类型转换的，赋值运算符右侧的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型
   （8）当把较长的整数转换为较短的整数或者char类型时，查出的高位部分将被丢弃，
   （9）（类型名）表达式 ，在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换，例如：sqrt((double)n);
   在把n传递给函数sqrt之前先将其转换为double类型，注意：强制类型转换只是生成一个指定类型的n的值，n本身的值并没有改变。
*/
